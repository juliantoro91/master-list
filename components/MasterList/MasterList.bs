' By juliantoro91.  More info: https://github.com/juliantoro91

sub init()
    initialSetup()
    setVariables()
    setObservers()
end sub

sub initialSetup()
    initialSettings = {
        wrap : true
        duration : 0.3
        showTargetRects : true
        usePlainStyle : false
        fixedFocus : false
        enableAnimation : true
        numRects : 0
        minFocused : 0
        maxFocused : 0
        cardWidth : 0
        cardHeight : 0
        cardSpacing : 0
    }

    m.top.update(initialSettings, true)
end sub

sub setVariables()
    m.indexes = {
        targetSet : 0
        maxTargetSet: 0
        content : 0
        maxContent : 0
    }

    m.navigation = {
        active : false
        press : false
        key : ""
    }

    m.changeTargetSet = true ' Check if it's required
    m.animateTargetSetChange = true ' Check behavior and move to initial settings
    m.moveFocusIndex = true ' Check behavior and move to initial settings

    m.changeContentIndex = true ' Check if it's required
end sub

sub setObservers()
    m.top.observefield("currFocusItemIndex", "onCurrFocusItemIndexChange")
    m.top.observefield("itemSelected", "onItemSelectedChange")
    m.top.observefield("itemFocused", "onItemFocusedChange")
    m.top.observefield("itemUnfocused", "onItemUnfocusedChange")
    m.top.observefield("content", "onContentChange")
end sub

' itemComponentName
' wrap
' duration
' showTargetRects
' numRects
sub configureComponent(event as object)
    settings = event.getData()

    m.top.update(settings, true)

    setupRects()
    m.top.targetSet = m.sets[m.indexes.targetSet]

    ' Apply clipping rect to discard flashing cards
    x = 0
    y = 0
    width = (m.top.cardWidth + m.top.cardSpacing) * m.top.numRects - m.top.cardSpacing
    height = m.top.cardHeight
    m.top.clippingRect = [x, y, width, height]
end sub

sub onContentChange(event as object)
    content = event.getData()

    m.indexes.maxContent = content.getChildCount() - 1
end sub

sub setupRects()
    m.sets = generateTargetSets()
end sub

function generateTargetSets() as object
    ' Adjustment required for the presence of flashing cards
    m.top.minFocused++
    m.top.maxFocused++

    ' Control variables
    numRects = m.top.numRects
    minFocused = m.top.minFocused
    maxFocused = (m.top.maxFocused > m.top.minFocused) ? m.top.maxFocused : numRects - 1
    maxFocused = m.top.fixedFocus ? m.top.minFocused : maxFocused

    ' Configure sets
    sets = createObject("roArray", (maxFocused - minFocused) + 1, false) ' TODO: Check if it's practical to block resizing

    setIndex = 0
    for i = minFocused to maxFocused
        sets[setIndex] = generateTargetSet(i)
        setIndex++
    end for

    m.indexes.maxTargetSet = sets.count() - 1

    return sets
end function

function generateTargetSet(focusIndex as integer) as object
    numRects = m.top.numRects + 2 ' This value is added to avoid flashing cards

    set = createObject("roSGNode", "TargetSet")
    rects = createObject("roArray", numRects, false)

    x = -(m.top.cardWidth + m.top.cardSpacing)
    y = 0
    width = m.top.cardWidth
    height = m.top.cardHeight
    spacing = m.top.cardSpacing
    yOffset = m.top.usePlainStyle ? 0 : 5
    widthOffset = m.top.usePlainStyle ? 0 : 20
    heightOffset = m.top.usePlainStyle ? 0 : 10

    for i = 0 to numRects - 1
        rects[i] = [
            x,
            i = focusIndex ? y + yOffset : y,
            i = focusIndex ? width + widthOffset : width,
            i = focusIndex ? height + heightOffset : height
        ]

        x = x + width + spacing
    end for

    set.targetRects = rects
    set.focusIndex = focusIndex

    return set
end function

function onKeyEvent(key as string, press as boolean) as boolean
    m.navigation.press = press
    m.navigation.key = key

    if not press then return false
    if m.navigation.active = true then return true

    result = false

    if key = "left"
        moveBackguard()
        result = true
    else if key = "right"
        moveForward()
        result = true
    end if

    return result
end function

sub moveBackguard()
    avoidAnimation = (m.indexes.content = 0 and m.top.wrap) ? true : false
    nextContentIndex = (m.indexes.content > 0) ? m.indexes.content - 1 : (m.top.wrap ? m.indexes.maxContent : 0)
    nextTargetSetIndex = (m.indexes.targetSet > 0) ? m.indexes.targetSet - 1 : 0

    navigateAction(nextContentIndex, nextTargetSetIndex, avoidAnimation)
end sub

sub moveForward()
    avoidAnimation = (m.indexes.content = m.indexes.maxContent and m.top.wrap) ? true : false
    nextContentIndex = (m.indexes.content < m.indexes.maxContent) ? m.indexes.content + 1 : (m.top.wrap ? 0 : m.indexes.maxContent)
    nextTargetSetIndex = (m.indexes.targetSet < m.indexes.maxTargetSet) ? m.indexes.targetSet + 1 : m.indexes.maxTargetSet

    navigateAction(nextContentIndex, nextTargetSetIndex, avoidAnimation)
end sub

sub navigateAction(nextContentIndex as integer, nextTargetSetIndex as integer, avoidAnimation=false as boolean)
    if nextTargetSetIndex <> m.indexes.targetSet
        if m.changeTargetSet
            m.indexes.targetSet = nextTargetSetIndex
            if m.animateTargetSetChange
                m.top.animateToTargetSet = m.sets[m.indexes.targetSet]
            else if m.moveFocusIndex
                m.top.targetSet.focusIndex = m.indexes.targetSet
            else
                m.top.targetSet = m.sets[m.indexes.targetSet]
            end if
        end if
    end if

    if m.changeContentIndex
        m.indexes.content = nextContentIndex
        if m.top.enableAnimation and not avoidAnimation
            m.top.animateToItem = m.indexes.content
        else
            m.top.jumpToItem = m.indexes.content
        end if
    end if
end sub

sub onCurrFocusItemIndexChange(event as object)
    data = event.getData()

    if data - int(data) = 0 and m.navigation.press = true
        if m.navigation.key = "left"
            moveBackguard()
        else if m.navigation.key = "right"
            moveForward()
        end if
    end if
end sub

sub onItemFocusedChange()
    m.navigation.active = false
end sub

sub onItemUnfocusedChange()
    m.navigation.active = true
end sub


' Interfaces to check
'' currTargetSet
'' easeFunction
'' advancing
'' reversing

' GETTERS
function get(key as string) as dynamic
    getters = {
        top : m.top
        dimensions : function () as object
            return m.top.clippingRect
        end function
    }

    value = getters[key]

    return type(value) = "roFunction" ? value() : value
end function
